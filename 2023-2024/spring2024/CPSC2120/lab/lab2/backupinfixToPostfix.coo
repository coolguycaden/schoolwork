/*
 * Name: Caden Allen
 * Date Submitted: 2/4/2024
 * Lab Section: 001
 * Assignment Name: Infix to Postfix
 */

#include <string>
#include <stack>
#include <iostream>

using namespace std;

//The use of this function is to be an easy way to compare
//operator priority
//Takes in the sent operator, and returns the associated
//priority with it as an int to compare to another operator's
//priorit
//Has built in function for parentheses to make checking them 
//easier
int getPriority(string inString){
	char stringToChar = inString[0];

	switch(stringToChar){
		case '(': case ')':
			return 3;

		case '/': case '*': case '%':
			return 2;

		case '+': case '-': 
			return 1;

		default:
			//character sent in is numeric
			return 0;
	}
	
	return 0;
}



//Converts an infix arithmetic expression into postfix
//The function takes 3 parameters
//First parameter: array of strings for infix expression
//    each string is either an integer number or operator symbol
//Second parameter: number of strings in infix expression
//Third parameter: array of strings for postfix expression
//    generated by function, same format as first parameter
//    assumes that postfix is at least the size of postfix
//Return value: int, number of strings in postfix expression
//    Returns 0 if an error is encountered when converting expression
//    An error occurs with a mismatched parenthesis, e.g. ( ( ) or ( ) ) etc.
//Operator symbols:
// ( : left parenthesis, all operations between this and ")" take place first
// ) : right parenthesis, all op.s back to previous "(" take place first
// * : multiplication, higher precedence - takes place before "+" and "-"
// / : division, higher precedence - takes place before "+" and "-"
// % : remainder, higher precedence - takes place before "+" and "-"
// + : addition, lower precedence - takes place after "*" , "/" , "%"
// - : subtraction, lower precedence - takes place after "*" , "/" , "%"
//The function is not specified to work with any other operator symbols
//Any string in infix may be assumed to be an integer operand if none
// of the above symbols
int infixToPostfix(string infix[], int length, string postfix[]){
		
	stack<string> operatorStack;
	
	int firstEmptyIndex = 0;
	int foundLeftParentheses = 0;
	int foundRightParentheses = 0;

	for(int x = 0; x < length; x++){
		if(infix[x] ==  "("){
			foundLeftParentheses++;
		}
		
		if(infix[x] == ")"){
			foundRightParentheses++;
		}
		
		if(getPriority(infix[x]) != 0 && getPriority(infix[x]) != 3){
			if(getPriority(infix[x - 1]) != 0 && getPriority(infix[x - 1]) != 3){
				//cout << infix[x] << " and " << infix[ x - 1 ] << endl;
				//cout << "improper equation" << endl;
				return 3;
			}
		}
	
		if(getPriority(infix[x]) == 0){
		
			postfix[firstEmptyIndex] = infix[x];
			cout << " added number: " << infix[x] << endl;
			firstEmptyIndex++;

		} else if(infix[x] == "("){
			operatorStack.push(infix[x]);	
			cout << " pushed paren " << endl;
		
		} else if(infix[x] == ")"){
			cout << " in paren " << endl;
			while(operatorStack.top() != "("){
				postfix[firstEmptyIndex] = operatorStack.top();
				cout << " popped inside paren " << operatorStack.top() << endl;
				operatorStack.pop();
				firstEmptyIndex++;
			}
			cout << " paren now " << operatorStack.top() << endl;
			operatorStack.pop();
			cout << " top now " << operatorStack.top() << endl;

		} else {//(getPriority(infix[x]) != 0){
			while(operatorStack.size() > 0 && getPriority(infix[x]) <= getPriority(operatorStack.top()) 
			      && operatorStack.top() != "("){	
				postfix[firstEmptyIndex] = operatorStack.top();
				cout << " popped " << operatorStack.top() << endl;
				operatorStack.pop();
				firstEmptyIndex++;
			      }
			
			cout << " pushed " << infix[x] << endl;
			operatorStack.push(infix[x]);
		}
		
		/*if(getPriority(infix[x]) != 0){
			
			cout << " pushed " << infix[x] << endl;
			operatorStack.push(infix[x]);
			
			if(operatorStack.size() > 1){
				
				//operator just pushed onto stack
				string tempOperator = operatorStack.top();
				operatorStack.pop();
				cout << " temp: " << tempOperator << endl;
				cout << " top: " << operatorStack.top() << endl;	
				
				if(getPriority(operatorStack.top()) >= getPriority(tempOperator)){
					
					cout << " priority lower " << tempOperator << endl;
					//while(getPriority(tempOperator) != 3 && getPriority(operatorStack.top()) != 3
					//&& operatorStack.size() != 0){
					while((tempOperator != ")" && tempOperator != "(") && operatorStack.size() != 0){	
						if(getPriority(operatorStack.top()) != 3){
							postfix[firstEmptyIndex] = operatorStack.top();
							cout << " adding " << operatorStack.top() << endl;
							firstEmptyIndex++;
							
						} else {

						}
						
						cout << " popped " << operatorStack.top() << endl;
						operatorStack.pop();
					}	
					
				
				} else {

					while(tempOperator == ")"){
						cout << " paren loop" << endl;
						if(operatorStack.top() == "("){
							cout << " ending paren " << operatorStack.top() << endl;
							operatorStack.pop();
							tempOperator = "";
						} else {
							postfix[firstEmptyIndex] = operatorStack.top();
							cout << " paren pop" << operatorStack.top() << endl;
							operatorStack.pop();
							firstEmptyIndex++;
						
						}
					}

					cout << " pushed back " << tempOperator << endl;
					operatorStack.push(tempOperator);
				}
				
			}

		} else {
			cout << "added " << infix[x] << endl;
			postfix[firstEmptyIndex] = infix[x];
			firstEmptyIndex++;

		}*/
		
		cout << "list now: ";
		for(int y = 0; y < firstEmptyIndex; y++){
			cout << postfix[y] << " "; 
		}
		
		cout << endl;


	}



	if(foundLeftParentheses != foundRightParentheses){
	//	cout << "no matching paren" << endl;
		return 0;
	}
	
	//What function performs so far
	// should be:
	// 1 2 3 * + 4 5 * 6 + 7 * +
	// 
	// 1 2 * 3 + 4 * 5 + 6 * 7 + 
	// 1 2 3 * + 4 5 * + 6 7 * + 
	//
	/*
	int y = 0;

	while(y < firstEmptyIndex - 1){
		if(getPriority(postfix[y]) == 2){
			string temp = postfix[y];
			//cout << " swapped " << temp;
			postfix[y] = postfix[y + 1];
			postfix[y + 1] = temp;
			//cout << " with " << postfix[x] << endl;
			y += 2;
		}

		y++;
	}
	*/
	//for(x = 0; x < length; x++){
	//	cout << x << ": " << postfix[x] << endl;
	//}
	while(!operatorStack.empty()){
		cout << " adding " << operatorStack.top() << endl;
		postfix[firstEmptyIndex] = operatorStack.top();
		firstEmptyIndex++;
		operatorStack.pop();
	}	
	
	return firstEmptyIndex;
}



/*
 *
//Main function to test infixToPostfix()
//Should convert 2 + 3 * 4 + ( 5 - 6 + 7 ) * 8
//            to 2 3 4 * + 5 6 - 7 + 8 * +
int main()
{
   // string infixExp[] = {"2", "+", "3", "*", "4", "+", "(",
     //                    "5", "-", "6", "+", "7", ")", "*",
       //                  "8"};
    
    string infixExp[] = {"1", "+", "2", "*", "3", "+", "(",
                         "4", "*", "5", "+", "6", ")", "*",
                         "7"};
   

    string postfixExp[15];
    int postfixLength;

    cout << "Infix expression: ";
    for (int i=0; i<15; i++)
    {
        cout << infixExp[i] << " ";
    }
    cout << endl;
    cout << "Length: 15" << endl << endl;

    postfixLength = infixToPostfix(infixExp, 15, postfixExp);

    cout << "       Postfix expression: ";
    for (int i=0; i<postfixLength; i++)
    {
        cout << postfixExp[i] << " ";
    }
    cout << endl;
    cout << "Proper Postfix expression: 1 2 3 * + 4 5 * 6 + 7 * + ";
    cout << endl;
    cout << "Length: " << postfixLength << endl;
    
    return 0;
}*/
